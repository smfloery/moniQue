# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MoniQueDialog
                                 A QGIS plugin
 Monoplotting oblique images.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-02-07
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Sebastian Mikolka-Flöry
        email                : s.floery@gmx.at
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import time
from qgis.PyQt import QtWidgets, QtCore, QtGui
from qgis.gui import QgsMapCanvas, QgsRubberBand
from wgpu.gui.qt import WgpuCanvas
from wgpu.gui.offscreen import WgpuCanvas as offscreenCanvas
import pygfx as gfx
import open3d as o3d
import numpy as np
# import imageio.v3 as iio
from PIL import Image
from osgeo import gdal
import json
import sys
import urllib.request
import glob

from collections import OrderedDict
from qgis.utils import iface

from qgis.core import QgsFeature, QgsPoint, QgsRasterLayer, QgsProject, QgsJsonUtils, QgsGeometry, QgsCoordinateReferenceSystem, QgsCoordinateTransform, Qgis, QgsPointXY
from qgis.gui import QgsMapToolPan
from qgis.PyQt.QtWidgets import QFileDialog

from PyQt5.QtGui import QColor, QCursor
from PyQt5.QtCore import Qt

from .dlg_create import CreateDialog
from .dlg_orient import OrientDialog
from .dlg_meta_gcp import GcpMetaDialog
from .dlg_meta_export import ExportMetaDialog
# from .dlg_import_akon import ImportAkonDialog
from .dlg_meta_mono import MonoMetaDialog
from ..tools.ImgPickerTool import ImgPickerTool
from ..tools.MonoMapTool import MonoMapTool
from ..tools.SelectTool import SelectTool
from ..tools.VertexTool import VertexTool
from ..tools.jsonImport import jsonImport

from ..camera import Camera
from ..helpers import create_point_3d, rot2alzeka, alzeka2rot, calc_hfov, calc_vfov

from ..tools.map_controller import OrbitFlightController
from ..tools.img_controller import ImageController

class MainDialog(QtWidgets.QDialog):
    
    load_project_signal = QtCore.pyqtSignal(object)
    close_dialog_signal = QtCore.pyqtSignal()
    
    def __init__(self, parent=None, plugin_dir=None):
        """Constructor."""
        super(MainDialog, self).__init__()
        
        self.parent = parent
        self.msg_bar = self.parent.iface.messageBar()
        self.plugin_dir = plugin_dir
        self.icon_dir = os.path.join(self.plugin_dir, "gfx", "icon")
        
        #will be set from monique.py
        self.camera_collection = None
        self.tiles_data = None
        self.initial_render = True
        self.project_pos_toggled = False
        self.temporary_camera = None
        self.orient_dlg_open = False
        
        self.setWindowTitle("moniQue")
        self.setWindowFlag(QtCore.Qt.WindowMaximizeButtonHint, True)
        self.setWindowIcon(QtGui.QIcon(os.path.join(self.plugin_dir, "icon.png")))

        self.menu = QtWidgets.QMenuBar(self)
        self.file_menu = QtWidgets.QMenu("&File", self)
        self.menu.addMenu(self.file_menu)
        
        self.img_menu = QtWidgets.QMenu("&Images", self)
        self.img_menu.setEnabled(False)
        self.menu.addMenu(self.img_menu)

        self.export_menu = QtWidgets.QMenu("&Export", self)
        self.export_menu.setEnabled(False)
        self.menu.addMenu(self.export_menu)

        self.view_menu = QtWidgets.QMenu("&View", self)
        self.view_menu.setEnabled(False)
        self.menu.addMenu(self.view_menu)
        
        self.create_action = QtWidgets.QAction("&New project", self)
        self.create_action.triggered.connect(self.show_dlg_create)
        self.file_menu.addAction(self.create_action)
        
        self.load_action = QtWidgets.QAction("&Load project", self)
        self.load_action.triggered.connect(self.load_project)
        self.file_menu.addAction(self.load_action)
        
        self.save_as_action = QtWidgets.QAction("&Save project as", self)
        self.save_as_action.triggered.connect(self.save_project_as)
        self.file_menu.addAction(self.save_as_action)
        
        self.import_action = QtWidgets.QAction("&Import images", self)
        self.import_action.triggered.connect(self.import_images)
        self.img_menu.addAction(self.import_action)

        self.import_json_action = QtWidgets.QAction("&Get initial orientation from *.json", self)
        self.import_json_action.triggered.connect(self.import_json)
        self.img_menu.addAction(self.import_json_action)

        self.export_action = QtWidgets.QAction("&Export Object View to PNG", self)
        self.export_action.triggered.connect(self.export_obj_canvas)
        self.export_menu.addAction(self.export_action)

        self.showCam_action = QtWidgets.QAction("&Show Camera Position in 3D Canvas", self)
        self.showCam_action.triggered.connect(self.showCam)
        self.view_menu.addAction(self.showCam_action)

        self.main_toolbar = QtWidgets.QToolBar("Main toolbar")
        self.main_toolbar.setIconSize(QtCore.QSize(24, 24))

        self.btn_ori_tool = QtWidgets.QAction("Open orientation dialog", self)
        self.btn_ori_tool.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "open_orientation_dialog.png")))
        self.btn_ori_tool.triggered.connect(self.show_dlg_orient)
        self.btn_ori_tool.setCheckable(True)
        self.btn_ori_tool.setEnabled(False)
        self.main_toolbar.addAction(self.btn_ori_tool)
        
        self.main_toolbar.addSeparator()
        
        self.btn_mono_tool = QtWidgets.QAction("Activate monoplotting tool", self)
        self.btn_mono_tool.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "mActionAddPolyline.png")))
        self.btn_mono_tool.setEnabled(False)
        self.btn_mono_tool.setCheckable(True)
        self.btn_mono_tool.triggered.connect(self.toggle_mono_tool)
        self.main_toolbar.addAction(self.btn_mono_tool)
        
        self.btn_mono_select = QtWidgets.QAction("Select monoplotted lines", self)
        self.btn_mono_select.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "mActionSelectRectangle.png")))
        self.btn_mono_select.setEnabled(False)
        self.btn_mono_select.setCheckable(True)
        self.btn_mono_select.triggered.connect(self.toggle_mono_select_tool)
        self.main_toolbar.addAction(self.btn_mono_select)
        
        self.btn_mono_vertex = QtWidgets.QAction("Edit monoplotted lines", self)
        self.btn_mono_vertex.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "mActionVertexToolActiveLayer.png")))
        self.btn_mono_vertex.setEnabled(False)
        self.btn_mono_vertex.setCheckable(True)
        self.btn_mono_vertex.triggered.connect(self.toggle_mono_vertex_tool)
        self.main_toolbar.addAction(self.btn_mono_vertex)
        
        self.img_toolbar = QtWidgets.QToolBar()
        self.img_toolbar.setIconSize(QtCore.QSize(24, 24))
        
        self.img_canvas = QgsMapCanvas(parent=self)
        self.img_canvas.setMinimumSize(QtCore.QSize(300, 16777215))
        
        self.img_pan_tool = QgsMapToolPan(self.img_canvas)
        self.mono_tool = MonoMapTool(self.img_canvas, self.parent.map_canvas, MonoMetaDialog())
        self.mono_vertex_tool = VertexTool(self.img_canvas, self.parent.map_canvas)
        self.mono_select_tool = SelectTool(self.img_canvas)
        
        btn_img_pan = QtWidgets.QAction("Pan (Image)", self)
        btn_img_pan.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "mActionPan.png")))
        btn_img_pan.setCheckable(True)
        self.img_toolbar.addAction(btn_img_pan)
        
        btn_img_extent = QtWidgets.QAction("Zoom to image extent.", self)
        btn_img_extent.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "mActionZoomFullExtent.png")))
        btn_img_extent.triggered.connect(self.set_img_canvas_extent)
        self.img_toolbar.addAction(btn_img_extent)
        
        self.obj_toolbar = QtWidgets.QToolBar()
        self.obj_toolbar.setIconSize(QtCore.QSize(24, 24))
        self.obj_canvas = WgpuCanvas(parent=self)
        self.obj_canvas.setMinimumSize(QtCore.QSize(300, 16777215))

        btn_reset_obj_canvas_camera = QtWidgets.QAction("Reset to default camera position", self)
        btn_reset_obj_canvas_camera.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "zoom_to_extent.png")))
        btn_reset_obj_canvas_camera.triggered.connect(self.reset_obj_canvas_camera)
        self.obj_toolbar.addAction(btn_reset_obj_canvas_camera)

        btn_save_obj_canvas_camera = QtWidgets.QAction("Save camera position.", self)
        btn_save_obj_canvas_camera.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "save_temporary_camera_position.png")))
        btn_save_obj_canvas_camera.triggered.connect(self.save_obj_canvas_camera)
        self.obj_toolbar.addAction(btn_save_obj_canvas_camera)

        btn_load_obj_canvas_camera = QtWidgets.QAction("Zoom to saved camera position.", self)
        btn_load_obj_canvas_camera.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "set_temporary_camera_position.png")))
        btn_load_obj_canvas_camera.triggered.connect(self.load_obj_canvas_camera)
        self.obj_toolbar.addAction(btn_load_obj_canvas_camera)

        btn_obj_canvas_camera_from_map = QtWidgets.QAction("Set camera position from current QGIS map canvas", self)
        btn_obj_canvas_camera_from_map.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "sync_views.png")))
        btn_obj_canvas_camera_from_map.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "mExtentFromMap.png")))

        btn_obj_canvas_camera_from_map.triggered.connect(self.obj_canvas_camera_from_map)
        self.obj_toolbar.addAction(btn_obj_canvas_camera_from_map)
        
        self.btn_obj_canvas_show_img = QtWidgets.QAction("Render image in 3D canvas", self)
        self.btn_obj_canvas_show_img.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "add_image_to_3d_canvas.png")))
        self.btn_obj_canvas_show_img.triggered.connect(self.show_img_in_obj_canvas)
        self.btn_obj_canvas_show_img.setEnabled(False)
        self.btn_obj_canvas_show_img.setCheckable(True)
        self.obj_toolbar.addAction(self.btn_obj_canvas_show_img)

        self.obj_renderer = gfx.WgpuRenderer(self.obj_canvas)
        self.obj_scene = gfx.Scene()
        self.obj_stats = gfx.Stats(viewport=self.obj_renderer)

        self.background = gfx.Background(None, gfx.BackgroundMaterial([1, 1, 1, 1]))
        self.obj_scene.add(self.background)
        
        self.img_plane_grp = gfx.Group()
        self.obj_scene.add(self.img_plane_grp)

        self.cam_planes_grp = gfx.Group()
        self.obj_scene.add(self.cam_planes_grp)

        self.cam_lines_grp = gfx.Group()
        self.obj_scene.add(self.cam_lines_grp)
        
        self.obj_camera = gfx.PerspectiveCamera(fov=45, depth_range=(1, 100000))
        
        self.obj_canvas.request_draw()

        self.obj_controller = OrbitFlightController(self.obj_camera, speed=2500, register_events=self.obj_renderer, damping=0)
        self.img_controller = ImageController(self.obj_camera, register_events=self.obj_renderer, damping=0)
        self.img_controller.enabled = False

        self.list_toolbar = QtWidgets.QToolBar()
        self.list_toolbar.setIconSize(QtCore.QSize(20, 20))
        
        self.img_list = QtWidgets.QListWidget()
        self.img_list.setContextMenuPolicy(3)   #call customContextMenu
        self.img_list.setAlternatingRowColors(True)
        self.img_list.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.img_list.itemClicked.connect(self.camera_clicked)
        self.img_list.customContextMenuRequested.connect(self.show_image_menu)
        
        self.prev_img_item = None
        
        self.split_canvas = QtWidgets.QSplitter()
        split_max_width = QtWidgets.QApplication.primaryScreen().size().width()
        
        self.img_split = QtWidgets.QWidget()
        img_split_layout = QtWidgets.QVBoxLayout()
        img_split_layout.setSpacing(0)
        img_split_layout.setContentsMargins(0, 0, 0, 0)
        img_split_layout.addWidget(self.img_toolbar)
        img_split_layout.addWidget(self.img_canvas)
        self.img_split.setLayout(img_split_layout)
        
        self.obj_split = QtWidgets.QWidget()
        obj_split_layout = QtWidgets.QVBoxLayout()
        obj_split_layout.setSpacing(0)
        obj_split_layout.setContentsMargins(0, 0, 5, 0)
        obj_split_layout.addWidget(self.obj_toolbar)
        obj_split_layout.addWidget(self.obj_canvas)
        self.obj_split.setLayout(obj_split_layout)
        
        self.split_canvas.addWidget(self.img_split)
        self.split_canvas.addWidget(self.obj_split)
        self.split_canvas.setSizes([split_max_width, split_max_width])
        
        self.list_widget = QtWidgets.QWidget()
        self.list_widget.setMinimumSize(QtCore.QSize(150, 16777215))
        self.list_widget.setMaximumSize(QtCore.QSize(150, 16777215))
        list_widget_layout = QtWidgets.QVBoxLayout()
        list_widget_layout.setSpacing(0)
        list_widget_layout.setContentsMargins(0, 16, 0, 0)
        list_widget_layout.addWidget(self.list_toolbar)
        list_widget_layout.addWidget(self.img_list)
        self.list_widget.setLayout(list_widget_layout)
        
        main_layout = QtWidgets.QHBoxLayout()
        main_layout.setSpacing(0)
        main_layout.setContentsMargins(5, 0, 5, 0)
        main_layout.addWidget(self.split_canvas)
        main_layout.addWidget(self.list_widget)

        layout = QtWidgets.QVBoxLayout()
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 5)
        layout.setMenuBar(self.menu)
        layout.addWidget(self.main_toolbar)
        layout.addLayout(main_layout)
        self.setLayout(layout)
        
        self.sel_gid = None
        self.obj_camera_state = None
        self.obj_camera_origin = None
        self.origin_memory = []

        self.json_check = False
        self.map_check = False

        self.cam_dict = {}
        self.showCam_check = False
        
        self.img_context_menu = QtWidgets.QMenu(self)
        action1 = QtGui.QAction('Action 1', self)
        action2 = QtGui.QAction('Action 2', self)
        self.img_context_menu.addAction(action1)
        self.img_context_menu.addAction(action2)
        
    def set_layers(self, lyr_dict):
        self.reg_lyr = lyr_dict["reg_lyr"]
        self.cam_lyr = lyr_dict["cam_lyr"]        
        self.img_lyr = None                     #will be set layer when terrestrial image is loaded
        
        self.img_line_lyr = lyr_dict["img_line_lyr"]
        self.map_line_lyr = lyr_dict["map_line_lyr"]
        
        self.img_gcps_lyr = lyr_dict["img_gcps_lyr"]
        self.map_gcps_lyr = lyr_dict["map_gcps_lyr"]
        
        self.img_gcps_gid_ix = self.img_gcps_lyr.dataProvider().fieldNameIndex('gid')
        
        self.map_gcps_gid_ix = self.map_gcps_lyr.dataProvider().fieldNameIndex('gid')
        self.map_gcps_lyr_obj_x_ix = self.map_gcps_lyr.dataProvider().fieldNameIndex('obj_x')
        self.map_gcps_lyr_obj_y_ix = self.map_gcps_lyr.dataProvider().fieldNameIndex('obj_y')
        self.map_gcps_lyr_obj_z_ix = self.map_gcps_lyr.dataProvider().fieldNameIndex('obj_z')
        
        #define layers which should be shown/considered in which canvas
        self.img_canvas.setLayers([self.img_line_lyr, self.img_gcps_lyr])
        self.img_canvas.setMapTool(self.img_pan_tool)
        
        self.mono_tool.set_layers(self.img_line_lyr, self.map_line_lyr)
        self.mono_select_tool.set_layers(self.img_line_lyr, self.map_line_lyr)
        self.mono_vertex_tool.set_layers(self.img_line_lyr, self.map_line_lyr)
        
    def show_dlg_create(self):
        self.dlg_create = CreateDialog(parent=self, icon_dir=self.icon_dir)
        self.dlg_create.created_signal.connect(self.on_created_signal)
        self.dlg_create.show()
    
    def show_dlg_orient(self):
        if self.btn_ori_tool.isChecked() or self.json_check == True:
            self.dlg_orient = OrientDialog(parent=self, icon_dir=self.icon_dir, active_iid=self.active_camera.iid)

            self.dlg_orient.gcp_selected_signal.connect(self.select_gcp)
            self.dlg_orient.gcp_deselected_signal.connect(self.deselect_gcp)
            self.dlg_orient.gcp_delete_signal.connect(self.delete_gcp)
            self.dlg_orient.gcp_imported_signal.connect(self.save_gcp_to_lyr)
            self.dlg_orient.get_camera_signal.connect(self.get_wpgu_camera)
            self.dlg_orient.camera_estimated_signal.connect(self.process_estimated_camera)
            self.dlg_orient.save_orientation_signal.connect(self.save_orientation_to_lyr)
            self.dlg_orient.activate_mouse_projection_signal.connect(self.toggle_project_mouse_pos)
            self.dlg_orient.deactivate_mouse_projection_signal.connect(self.untoggle_project_mouse_pos)
            self.dlg_orient.offset_signal.connect(self.show_offset_in_obj_canvas)

            self.dlg_orient.add_gcps_from_lyr(self.get_gcps_from_gpkg())

            if self.active_camera.is_oriented == 1:
                self.dlg_orient.set_init_params(self.active_camera.asdict())
                self.dlg_orient.btn_preview_pos.setEnabled(True)
                
            self.dlg_orient.show()
                        
    def on_created_signal(self, data):
        self.load_project(gpkg_path=data["gpkg_path"])
    
    def load_project(self, gpkg_path=None):
        if not gpkg_path:
            gpkg_path = QtWidgets.QFileDialog.getOpenFileName(None, "Open project", "", ("Geopackage (*.gpkg)"))[0]
        
        #load dialog could be cancled; hence, gkpk_path must not always be defined
        if gpkg_path:
            self.load_project_signal.emit({"gpkg_path":gpkg_path})
    
    def save_project_as(self):
        pass
    
    def closeEvent(self, event):
        
        if self.img_lyr is not None:
            QgsProject.instance().removeMapLayer(self.img_lyr.id())
            self.img_lyr = None
        
        if self.cam_lyr is not None:
            QgsProject.instance().removeMapLayer(self.cam_lyr.id())
            self.cam_lyr = None
        
        if self.img_line_lyr is not None:
            QgsProject.instance().removeMapLayer(self.img_line_lyr.id())
            self.img_line_lyr = None
        
        if self.img_gcps_lyr is not None:
            QgsProject.instance().removeMapLayer(self.img_gcps_lyr.id())
            self.img_gcps_lyr = None
        
        if self.map_line_lyr is not None:
            QgsProject.instance().removeMapLayer(self.map_line_lyr.id())
            self.map_line_lyr = None
        
        if self.map_gcps_lyr is not None:
            QgsProject.instance().removeMapLayer(self.map_gcps_lyr.id())
            self.map_gcps_lyr = None
        
        if self.reg_lyr is not None:
            QgsProject.instance().removeMapLayer(self.reg_lyr.id())
            self.reg_lyr = None
        
        self.img_canvas.refresh()
        self.close_dialog_signal.emit()
    
    def show_img_in_obj_canvas(self):
                
        if self.btn_obj_canvas_show_img.isChecked():    #activate
            
            #if GCP picking is not active show this cursor; otherwise leave the cross hair
            if not self.orient_dlg_open:
                self.obj_canvas.setCursor(QCursor(Qt.SizeVerCursor))           

            self.img_in_obj_check = True

            self.set_obj_canvas_camera(self.temporary_camera)
            
            self.img_list.setEnabled(False)
            self.img_controller.enabled = True
            self.obj_controller.enabled = False
            
            img_w = self.active_camera.img_w
            img_h = self.active_camera.img_h
                    
            prc = np.array([self.temporary_camera["obj_x0"], self.temporary_camera["obj_y0"], self.temporary_camera["obj_z0"]]) - self.min_xyz
            rmat = alzeka2rot([self.temporary_camera["alpha"], self.temporary_camera["zeta"], self.temporary_camera["kappa"]])
            cmat = np.array([[1, 0, -self.temporary_camera["img_x0"]], 
                            [0, 1, -self.temporary_camera["img_y0"]],
                            [0, 0, -self.temporary_camera["f"]]])
            
            plane_pnts_img = np.array([[0, 0, 1],
                                [img_w, 0, 1],
                                [img_w, img_h*(-1), 1],
                                [0, img_h*(-1), 1]]).T
            
            plane_pnts_dir = (rmat@cmat@plane_pnts_img).T
            plane_pnts_dir = plane_pnts_dir / np.linalg.norm(plane_pnts_dir, axis=1).reshape(-1, 1)
            
            plane_pnts_obj = prc + 1000 * plane_pnts_dir
            plane_faces = np.array([[3, 1, 0], [3, 2, 1]]).astype(np.uint32)
            plane_uv = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]).astype(np.uint32)
            
            plane_geom = gfx.geometries.Geometry(indices=plane_faces, 
                                                positions=plane_pnts_obj.astype(np.float32),
                                                texcoords=plane_uv.astype(np.float32))
            
            img_path = self.active_camera.path    
            img = Image.open(img_path)
            img_array = np.asarray(img)
            tex = gfx.Texture(img_array, dim=2)
            
            if gfx.__version__ != '0.7.0':
                plane_material = gfx.MeshBasicMaterial(map=tex, side="FRONT", map_interpolation="linear")
            else:
                plane_material = gfx.MeshBasicMaterial(map=tex, side="FRONT")
                
            plane_mesh = gfx.Mesh(plane_geom, plane_material, visible=True)
            
            self.img_controller.set_image(plane_mesh, plane_pnts_dir, prc, distance=1000)
            
            self.img_plane_grp.clear()
            self.img_plane_grp.add(plane_mesh)

            self.obj_canvas.request_draw()
            
        else:
            self.img_in_obj_check = False
            
            #only if the orient dialog is not open the image list should be made active again; change back to "normal" cursor
            if not self.orient_dlg_open:
                self.img_list.setEnabled(True)
                self.obj_canvas.setCursor(QCursor(Qt.ArrowCursor))
            else:   #if orient dialog is open change back to cross hair as GCP becomes active again
                self.obj_canvas.setCursor(QCursor(Qt.CrossCursor))

            self.img_controller.enabled = False
            self.obj_controller.enabled = True
            
            self.img_plane_grp.clear()
            self.obj_canvas.request_draw()

    def show_camera_in_obj_canvas(self, current_iid):

        for cam_feat in self.cam_lyr.getFeatures():

            if cam_feat['obj_x0'] != None:
                img_w = int(cam_feat['img_w'])
                img_h = int(cam_feat['img_h'])
                        
                prc = np.array([float(cam_feat["obj_x0"]), float(cam_feat["obj_y0"]), float(cam_feat["obj_z0"])]) - self.min_xyz
                rmat = alzeka2rot([float(cam_feat["alpha"]), float(cam_feat["zeta"]), float(cam_feat["kappa"])])
                cmat = np.array([[1, 0, -float(cam_feat["img_x0"])], 
                                    [0, 1, -float(cam_feat["img_y0"])],
                                    [0, 0, -float(cam_feat["f"])]])
                    
                plane_pnts_img = np.array([[0, 0, 1],
                                        [img_w, 0, 1],
                                        [img_w, img_h*(-1), 1],
                                        [0, img_h*(-1), 1]]).T
                    
                plane_pnts_dir = (rmat@cmat@plane_pnts_img).T
                plane_pnts_dir = plane_pnts_dir / np.linalg.norm(plane_pnts_dir, axis=1).reshape(-1, 1)
                    
                plane_pnts_obj = prc + 100 * plane_pnts_dir
                plane_faces = np.array([[3, 1, 0], [3, 2, 1]]).astype(np.uint32)
                plane_uv = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]).astype(np.uint32)
                    
                plane_geom = gfx.geometries.Geometry(indices=plane_faces, 
                                                        positions=plane_pnts_obj.astype(np.float32),
                                                        texcoords=plane_uv.astype(np.float32))
                    
                plane_material = gfx.MeshBasicMaterial(color = (1, 0.65, 0, 1), opacity=0.5)
                plane_mesh = gfx.Mesh(plane_geom, plane_material, visible=True)
                
                selected_plane_material = gfx.MeshBasicMaterial(color = (1, 0, 0, 1), opacity=0.5)
                selected_plane_mesh = gfx.Mesh(plane_geom, selected_plane_material, visible=True)

                #TODO: plane_mesh rot färben wenn entsprechendes Bild ausgewählt ist!
                    
                self.img_controller.set_image(plane_mesh, plane_pnts_dir, prc, distance=1000)
                
                positions = [[list(prc),plane_pnts_obj[i]] for i in range(4)]
                lines = [gfx.Line(gfx.Geometry(positions=positions[i]), gfx.LineMaterial(thickness=1.0, color=(1, 0.65, 0.0), opacity=1)) for i in range(4)]
                selected_lines = [gfx.Line(gfx.Geometry(positions=positions[i]), gfx.LineMaterial(thickness=1.0, color=(1, 0.0, 0.0), opacity=1)) for i in range(4)]

                if cam_feat['iid'] in self.cam_dict.keys():
                    self.cam_dict[cam_feat['iid']].clear()

                self.cam_dict[cam_feat['iid']] = gfx.Group(visible=self.showCam_check)
                self.obj_scene.add(self.cam_dict[cam_feat['iid']])

                if cam_feat['iid'] == current_iid:
                    self.cam_dict[cam_feat['iid']].add(selected_plane_mesh)
                else:
                    self.cam_dict[cam_feat['iid']].add(plane_mesh)

                if cam_feat['iid'] == current_iid:
                    for i in selected_lines:
                        self.cam_dict[cam_feat['iid']].add(i)
                else:
                    for i in lines:
                        self.cam_dict[cam_feat['iid']].add(i)


        self.obj_canvas.request_draw()

    def showCam(self):
        self.showCam_check = not self.showCam_check

        if self.showCam_check:
            for key in self.cam_dict.keys():
                self.cam_dict[key].visible = True
        else:
            for key in self.cam_dict.keys():
                self.cam_dict[key].visible = False

    def add_mesh_to_obj_canvas(self, tiles_data):
        
        self.tiles_data = tiles_data
        
        self.msg_box = QtWidgets.QProgressDialog("Loading tiles...", None, 0, len(self.tiles_data["tiles"])+1, self)
        self.msg_box.setWindowTitle("%s" % (self.parent.project_name))
        self.msg_box.setWindowModality(QtCore.Qt.WindowModal)
        self.msg_box.show()
        self.msg_box.setValue(0)
        QtWidgets.QApplication.processEvents()  #required otherwise msg_box stays empty and is not updated; found here: https://stackoverflow.com/questions/47879413/pyqt-qprogressdialog-displays-as-an-empty-white-window
                
        self.terrain = gfx.Group()
        self.min_xyz = np.array(self.tiles_data["min_xyz"])
        self.max_xyz = np.array(self.tiles_data["max_xyz"])

        self.show_camera_in_obj_canvas(0)
        
        self.o3d_scene = o3d.t.geometry.RaycastingScene()
        
        for tx, tile in enumerate(self.tiles_data["tiles"]):
            
            self.msg_box.setValue(tx+1)
            
            geom_path = os.path.join(self.tiles_data["tile_dir"], "%s.ply" % (tile["tid"]))
            op_path = glob.glob(os.path.join(self.tiles_data["op_dir"], "%s.jpg" % (tile["tid"])))
            op_path.extend(glob.glob(os.path.join(self.tiles_data["op_dir"], "%s.jpeg" % (tile["tid"]))))
            op_path.extend(glob.glob(os.path.join(self.tiles_data["op_dir"], "%s.png" % (tile["tid"]))))
            op_path.extend(glob.glob(os.path.join(self.tiles_data["op_dir"], "%s.tif" % (tile["tid"]))))
            
            if os.path.exists(geom_path):
                tile_mesh = o3d.io.read_triangle_mesh(geom_path)
                
                
                verts = np.asarray(tile_mesh.vertices).astype(np.float32)
                
                u = (verts[:, 0] - tile["min_xyz"][0])/(tile["max_xyz"][0] - tile["min_xyz"][0])
                v = (verts[:, 1] - tile["min_xyz"][1])/(tile["max_xyz"][1] - tile["min_xyz"][1])
                uv = np.hstack((u.reshape(-1, 1), v.reshape(-1, 1)))
                
                verts -= self.min_xyz
                faces = np.asarray(tile_mesh.triangles).astype(np.uint32)
                
                self.o3d_scene.add_triangles(verts, faces)
                                    
                # print("Loading mesh...")
                mesh_geom = gfx.geometries.Geometry(indices=faces, 
                                                    positions=verts,
                                                    texcoords=uv.astype(np.float32),
                                                    tid=[int(tile["tid_int"])])
            
                if len(op_path) == 1:                                
                    img_ds = gdal.Open(op_path[0])
                    img_h = img_ds.RasterYSize
                    img_w = img_ds.RasterXSize
                    img_arr = np.zeros((img_h, img_w, 3), dtype=np.uint8)
                                
                    for bx in range(3):
                        bx_arr = img_ds.GetRasterBand(bx+1).ReadAsArray()
                        img_arr[:, :, bx] = bx_arr
                                    
                    img_arr = np.flipud(img_arr)
                    tex = gfx.Texture(img_arr, dim=2, generate_mipmaps=True)
                    
                    #prior to 0.7.0 it was possible to defined the texture interpolation for meshes; appaers to be removed with 0.7.0
                    if gfx.__version__ != '0.7.0':
                        mesh_material = gfx.MeshBasicMaterial(map=tex, side="FRONT", map_interpolation="linear", pick_write=True)  
                    else:
                        mesh_material = gfx.MeshBasicMaterial(map=tex, side="FRONT", pick_write=True)
                else:
                    mesh_material = gfx.MeshNormalMaterial(side="FRONT", pick_write=True)
            
                #add lowest resolution material to mesh at startup
                mesh = gfx.Mesh(mesh_geom, mesh_material, visible=False)
                mesh.add_event_handler(self.zoom_to_point, "click")
                self.terrain.add(mesh)
            
        self.obj_scene.add(self.terrain)
        local_cx = self.tiles_data["cx"] - self.min_xyz
        
        offset_z = local_cx[0] / np.tan(np.deg2rad(self.obj_camera.get_state()["fov"])/2)
        
        self.obj_camera.local.position = local_cx + np.array([0, 0, offset_z])
        self.obj_camera.show_pos(local_cx)
        
        #intitial render call
        self.msg_box.setLabelText("Rendering initial scene...")
        QtWidgets.QApplication.processEvents()
        self.obj_canvas.request_draw(self.animate)  #request draw calls animate     
        
        #group that will hold all the GCPs on object space
        self.obj_gcps_grp = gfx.Group()
        self.obj_scene.add(self.obj_gcps_grp)
        
        self.obj_scene.add(gfx.AmbientLight(intensity=1), gfx.DirectionalLight())
        
        self.default_obj_camera_state = self.obj_camera.get_state()
        
        self.mono_tool.set_minxyz(self.min_xyz)
        self.mono_vertex_tool.set_minxyz(self.min_xyz)
                       
        self.mono_tool.set_scene(self.o3d_scene)
        self.mono_vertex_tool.set_scene(self.o3d_scene)
        
    def animate(self):     

        if self.tiles_data is not None:
                        
            # cam_pos = self.obj_camera.local.position
            frustum = self.obj_camera.frustum
            corners_flat = frustum.reshape((-1, 3))
                    
            corners_by_plane = np.stack([
                corners_flat[[0, 3, 7, 4], :],
                corners_flat[[5, 6, 2, 1], :],
                corners_flat[[3, 2, 6, 7], :],
                corners_flat[[4, 5, 1, 0], :],
                corners_flat[[1, 2, 3, 0], :],
                corners_flat[[4, 7, 6, 5], :]], axis=0)
                        
            # planes in normal form (normals point away from the frustum area)
            normals = np.cross(
                corners_by_plane[:, 0, :] - corners_by_plane[:, 3, :],
                corners_by_plane[:, 2, :] - corners_by_plane[:, 3, :]
            )
            
            normals /= np.linalg.norm(normals, axis=-1)[:, None] # normal normals ^_^
            # offset = np.sum(normals * corners_by_plane[:, 3, :], axis=-1)  #d=n*r0; r0 some point on the plane            
            
            # end_time = time.time()
            # print("%.6f" % (end_time - start_time))
            
            # start_time = time.time()
            for tile in self.tiles_data["tiles"]:
                result = "INSIDE"
                tile_cx = np.array(tile["cx_r"][:3]) - self.min_xyz
                
                for nx in range(6):
                    
                    #normal distance between any point on the plane and the sphere center                
                    #https://www.w3schools.blog/distance-of-a-point-from-a-plane
                    #simplest frustum culling technique; renderes more tiles than actually visible;
                    cx_c_vec = tile_cx - corners_by_plane[nx, 0, :]                    
                    cx_dist = np.dot(cx_c_vec, normals[nx, :])
                                    
                    if cx_dist > tile["cx_r"][-1]:
                        result="OUTSIDE"
                        break
                                    
                # #first tile added to group has tid_pygfx = 0; Hence, we can use this id to directly access the 
                # #respective children within the list; no need for an additional for loop;
                if result == "INSIDE":
                    self.terrain.children[int(tile["tid_int"])].visible = True
                else:
                    self.terrain.children[int(tile["tid_int"])].visible = False
                    
            self.obj_renderer.render(self.obj_scene, self.obj_camera, flush=True) #flash=True if fps not used anymore
            
            if self.initial_render is True:
                self.msg_box.setValue(len(self.tiles_data["tiles"])+1)
                QtWidgets.QApplication.instance().restoreOverrideCursor()
                self.initial_render = False        
                
    def import_images(self):
        """Import selected images.
        """       
        img_paths = QtWidgets.QFileDialog.getOpenFileNames(None, "Load images", "", ("Image (*.tif *.tiff *.png *.jpg *.jpeg)"))[0]
        loaded_imgs = [self.img_list.item(x).text() for x in range(self.img_list.count())]
        
        for path in img_paths:
            [img_name, img_ext] = os.path.basename(path).rsplit(".", 1)
            
            if img_name not in loaded_imgs:
                
                img = Image.open(path)
                img_h = img.height
                img_w = img.width
                                
                cam = Camera(iid=img_name, path=path, ext=img_ext, is_oriented=False, img_h=img_h, img_w=img_w)
                self.camera_collection[cam.iid] = cam
                
                self.add_camera_to_list(cam)
                self.add_camera_to_cam_lyr(cam)

    def import_json(self):
        """Import position and orientation from selected JSON.
        """

        json_path = QtWidgets.QFileDialog.getOpenFileName(None, "Import position/orientation from json", "", ("JSON (*.json)"))[0]

        try: 
            self.appr_cam_pos = jsonImport(json_path)
        except:
            print("Provided JSON does not appear to be valid.")
            return
        
        try:    
            cam_pos = self.appr_cam_pos.get_pos()[self.active_camera.iid]
            cam_ori = self.appr_cam_pos.get_ori()[self.active_camera.iid]

            data = {"obj_x0":cam_pos['X0'], "obj_y0":cam_pos['Y0'], "obj_z0":cam_pos['Z0'], 
                    "alpha":cam_ori['alpha'], "zeta":cam_ori['beta'], "kappa":cam_ori['gamma'],
                    "img_x0":self.active_camera.img_w/2., "img_y0":self.active_camera.img_h/2.*(-1), "f":np.sqrt(self.active_camera.img_w**2 + self.active_camera.img_h**2)}
            
            self.json_check = True

            self.show_dlg_orient()
            self.dlg_orient.set_init_params(data)
            self.process_estimated_camera(data)

            self.json_check = False

        except:
            print("Something went wrong while setting the initial camera parameters! \nPlease check if an image has been selected and try again.")
            self.json_check = False
            return   
                 
    def get_gcps_from_gpkg(self):
        gcps = OrderedDict()
        gcp_data = {"obj_x":None, "obj_y":None, "obj_z":None, "img_x":None, "img_y":None, "img_dx":None, "img_dy":None, "active":None}
        
        for feat in self.img_gcps_lyr.getFeatures():
            curr_gcp = gcp_data.copy()
            img_gcp = json.loads(QgsJsonUtils.exportAttributes(feat))
            
            curr_gid = img_gcp["gid"]
            
            curr_gcp["img_x"] = img_gcp["img_x"]
            curr_gcp["img_y"] = img_gcp["img_y"]
            curr_gcp["img_dx"] = img_gcp["img_dx"]
            curr_gcp["img_dy"] = img_gcp["img_dy"]
            curr_gcp["active"] = img_gcp["active"]
            
            gcps[curr_gid] = curr_gcp
        
        for feat in self.map_gcps_lyr.getFeatures():
            map_gcp = json.loads(QgsJsonUtils.exportAttributes(feat))
            curr_gid = map_gcp["gid"]
            
            if curr_gid in gcps.keys():
                gcps[curr_gid]["obj_x"] = map_gcp["obj_x"]
                gcps[curr_gid]["obj_y"] = map_gcp["obj_y"]
                gcps[curr_gid]["obj_z"] = map_gcp["obj_z"]
            else:
                curr_gcp = gcp_data.copy()
                curr_gcp["obj_x"] = map_gcp["obj_x"]
                curr_gcp["obj_y"] = map_gcp["obj_y"]
                curr_gcp["obj_z"] = map_gcp["obj_z"]
                curr_gcp["active"] = map_gcp["active"]
                
                gcps[curr_gid] = curr_gcp

        return gcps
    
    def select_gcp(self, data):
        self.sel_gid = data["gid"]
        self.map_gcps_lyr.selectByExpression("\"gid\"=%s"%(data["gid"]))
        self.img_gcps_lyr.selectByExpression("\"gid\"=%s"%(data["gid"]))
        
        for pnts in self.obj_gcps_grp.children:
            if int(data["gid"]) == int(pnts.geometry.gid.data[0]):
                pnts.material = gfx.PointsMaterial(color=(1, 0.98, 0, 1), size=10)
            else:
                pnts.material = gfx.PointsMaterial(color=(0.78, 0, 0, 1), size=10)
        
        self.obj_canvas.request_draw()
    
    def deselect_gcp(self):
        self.sel_gid = None
        self.map_gcps_lyr.removeSelection()
        self.img_gcps_lyr.removeSelection()

        for pnts in self.obj_gcps_grp.children:
            pnts.material = gfx.PointsMaterial(color=(0.78, 0, 0, 1), size=10)
        
        self.obj_canvas.request_draw()
        
    def delete_gcp(self, data):
        if self.map_gcps_lyr.selectedFeatureCount() > 0:
            self.map_gcps_lyr.startEditing()
            self.map_gcps_lyr.deleteSelectedFeatures() 
            self.map_gcps_lyr.commitChanges()
        
        if self.img_gcps_lyr.selectedFeatureCount() > 0:
            self.img_gcps_lyr.startEditing()
            self.img_gcps_lyr.deleteSelectedFeatures()
            self.img_gcps_lyr.commitChanges()

        del_gcp_obj = None
        for gcp_obj in self.obj_gcps_grp.children:
            if int(data["gid"]) == int(gcp_obj.geometry.gid.data[0]):
                del_gcp_obj = gcp_obj
                
        if del_gcp_obj:
            self.obj_gcps_grp.remove(del_gcp_obj)
            self.obj_canvas.request_draw()
            
    def add_camera_to_list(self, camera):
        """Add camera to the image list.

        Args:
            camera (_type_): Camera object.
        """
        
        item = QtWidgets.QListWidgetItem(camera.iid)
        item.setSizeHint(QtCore.QSize(24, 24))
        item.setFlags(item.flags() ^ QtCore.Qt.ItemIsUserCheckable)
        item.setCheckState(QtCore.Qt.Unchecked)
        self.img_list.addItem(item)

    def add_camera_to_cam_lyr(self, camera):
        """Add camera to the camera GPKG layer.

        Args:
            camera (_type_): Camera object.
        """
        feat = QgsFeature(self.cam_lyr.fields())
        feat["iid"] = camera.iid
        feat["path"] = camera.path
        feat["ext"] = camera.ext
        feat["img_w"] = camera.img_w
        feat["img_h"] = camera.img_h
        
        pr = self.cam_lyr.dataProvider()
        pr.addFeatures([feat])
                
        self.cam_lyr.commitChanges()

    def uncheck_list_items(self, item):
        for ix in range(self.img_list.count()):
            
            curr_item = self.img_list.item(ix)
            
            if (curr_item != item) & (curr_item.checkState() == QtCore.Qt.Checked):
                curr_item.setCheckState(QtCore.Qt.Unchecked)

    def load_img(self, iid, path):
        img_lyr = QgsRasterLayer(path, iid)
                
        if not img_lyr.isValid():
            self.msg_bar.pushCritical("Error", "Could not load %s!" % (path))
        else:
            if self.img_lyr is not None:
                QgsProject.instance().removeMapLayer(self.img_lyr.id())
            
            self.img_lyr = img_lyr
                
            # QgsProject.instance().addMapLayer(self.img_lyr, False) #False --> do not add layer to LayerTree --> not visible in qgis main canvas
            self.img_canvas.setExtent(self.img_lyr.extent())
            self.img_canvas.setLayers([self.img_gcps_lyr, self.img_line_lyr, self.img_lyr])
            self.img_canvas.refresh()
            
    def set_img_canvas_extent(self):
        self.img_canvas.setExtent(self.img_lyr.extent())
        self.img_canvas.refresh()
    
    def get_wpgu_camera(self):
        # cam_state = self.obj_camera.get_state()
        
        cam_pos = self.obj_camera.local.position + self.min_xyz

        #the camera appears to be exactly what alzeka needs; hence, we can directly derive alzeka from the rotation matrix
        cam_rmat_pygfx = self.obj_camera.local.rotation_matrix[:3, :3]  #already transposed in contrast to self.obj_camera.view_matrix; otherweise the same
        alzekas = rot2alzeka(cam_rmat_pygfx)
                
        data = {"obj_x0":cam_pos[0], "obj_y0":cam_pos[1], "obj_z0":cam_pos[2], 
                "alpha":alzekas[0, 0], "zeta":alzekas[0, 1], "kappa":alzekas[0, 2],
                "img_x0":self.active_camera.img_w/2., "img_y0":self.active_camera.img_h/2.*(-1), "f":np.sqrt(self.active_camera.img_w**2 + self.active_camera.img_h**2)}
        
        self.dlg_orient.set_init_params(data)
    
    def process_estimated_camera(self, data):
        
        est_hfov = calc_hfov(self.active_camera.img_w, data["f"])
        est_vfov = calc_vfov(self.active_camera.img_h, data["f"])
        data["hfov"] = est_hfov
        data["vfov"] = est_vfov
        
        self.set_obj_canvas_camera(data)
        # self.show_img_in_obj_canvas()
        
        if self.json_check == False:
            self.update_camera(data)
            self.update_gcps(data)
        
    def update_camera(self, data):
        curr_cam = list(self.cam_lyr.getFeatures(expression = "iid = '%s'" % (self.active_camera.iid)))[0]
        curr_cam_fid = curr_cam.id()
        
        self.cam_lyr.startEditing()
        
        self.cam_lyr.changeGeometry(curr_cam_fid, QgsGeometry.fromPoint(QgsPoint(data["obj_x0"], data["obj_y0"])))
        self.cam_lyr.changeAttributeValue(curr_cam_fid, curr_cam.fieldNameIndex("is_oriented"), 1)
        
        attrs = ["obj_x0", "obj_y0", "obj_z0", "alpha", "zeta", "kappa", "img_x0", "img_y0", "f", "hfov","vfov"]
        for attr in attrs:
            self.cam_lyr.changeAttributeValue(curr_cam_fid, curr_cam.fieldNameIndex(attr), float(data[attr]))
        
        attrs = ["obj_x0_std", "obj_y0_std", "obj_z0_std", "alpha_std", "zeta_std", "kappa_std", "f_std"]
        for attr in attrs:
            self.cam_lyr.changeAttributeValue(curr_cam_fid, curr_cam.fieldNameIndex(attr), float(data[attr]))
        
        self.cam_lyr.triggerRepaint()

        self.show_camera_in_obj_canvas(self.active_camera.iid)
    
    def update_gcps(self, data):
        curr_img_gcps = self.img_gcps_lyr.getFeatures(expression = "iid = '%s'" % (self.active_camera.iid))
        curr_map_gcps = self.map_gcps_lyr.getFeatures(expression = "iid = '%s'" % (self.active_camera.iid))
        
        used_gids = list(data["residuals"].keys())
        
        self.img_gcps_lyr.startEditing()
        self.map_gcps_lyr.startEditing()
        for gcp in curr_img_gcps:
            
            gcp_gid = str(gcp.attribute("gid"))
            gcp_fid = gcp.id()
                
            if gcp_gid in used_gids:
                self.img_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("img_dx"), float(data["residuals"][gcp_gid][0]))
                self.img_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("img_dy"), float(data["residuals"][gcp_gid][1]))
                self.img_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("active"), "1")
            else:
                self.img_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("img_dx"), None)
                self.img_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("img_dy"), None)
                self.img_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("active"), "0")
        
        for gcp in curr_map_gcps:
            
            gcp_gid = str(gcp.attribute("gid"))
            gcp_fid = gcp.id()
            
            if gcp_gid in used_gids:
                self.map_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("active"), "1")        
                for pnts in self.obj_gcps_grp.children:
                    if int(gcp_fid) == int(pnts.geometry.gid.data[0]):
                        pnts.material = gfx.PointsMaterial(color=(0.76, 0, 0, 1), size=10)        
            else:
                self.map_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("active"), "0")
                for pnts in self.obj_gcps_grp.children:
                    if int(gcp_fid) == int(pnts.geometry.gid.data[0]):
                        pnts.material = gfx.PointsMaterial(color=(0.87, 0.87, 0.87, 1), size=10)       
    
    def save_gcp_to_lyr(self, data):
        img_feat_geom = QgsPoint(data["img_x"], data["img_y"])
        
        img_feat = QgsFeature(self.img_gcps_lyr.fields())
        img_feat.setGeometry(img_feat_geom)
        img_feat.setAttribute("iid", self.active_camera.iid)
        img_feat.setAttribute("gid", data["gid"])
        img_feat.setAttribute("img_x", data["img_x"])
        img_feat.setAttribute("img_y", data["img_x"])
        img_feat.setAttribute("desc", "")
        img_feat.setAttribute("active", 1)
        
        map_feat = QgsFeature(self.map_gcps_lyr.fields())
        map_feat.setGeometry(QgsPoint(data["obj_x"], data["obj_y"]))
        map_feat["iid"] = self.active_camera.iid
        map_feat["gid"] = data["gid"]
        map_feat["obj_x"] = data["obj_x"]
        map_feat["obj_y"] = data["obj_y"]
        map_feat["obj_z"] = data["obj_z"]
        map_feat["desc"] = ""
        map_feat["active"] = 1
        
        _ = self.map_gcps_lyr.dataProvider().addFeatures([map_feat])
        _ = self.img_gcps_lyr.dataProvider().addFeatures([img_feat])
                
        self.map_gcps_lyr.commitChanges()                      
        self.img_gcps_lyr.commitChanges()
        
        self.map_gcps_lyr.triggerRepaint()
        self.img_gcps_lyr.triggerRepaint() 
    
    def save_orientation_to_lyr(self):
        self.cam_lyr.commitChanges()
        self.img_gcps_lyr.commitChanges()
        self.map_gcps_lyr.commitChanges()
        
        cam_feat = list(self.cam_lyr.getFeatures(expression = "iid = '%s'" % (self.active_camera.iid)))[0]
        cam_feat_json = json.loads(QgsJsonUtils.exportAttributes(cam_feat))
        
        del cam_feat_json["fid"]
        cam = Camera(**cam_feat_json)

        self.camera_collection[cam.iid] = cam
        self.active_camera = self.camera_collection[cam.iid]
        
    def discard_changes(self):
        self.img_gcps_lyr.rollBack()
        self.map_gcps_lyr.rollBack()
        self.cam_lyr.rollBack()
         
    def set_obj_canvas_camera(self, data):
        self.obj_camera.local.position = np.array([data["obj_x0"], data["obj_y0"], data["obj_z0"]]) - self.min_xyz
        
        photo_rmat = alzeka2rot([data["alpha"], data["zeta"], data["kappa"]])
        pygfx_rmat = np.zeros((4,4))
        pygfx_rmat[3, 3] = 1
        pygfx_rmat[:3, :3] = photo_rmat
            
        self.obj_camera.local.rotation_matrix = pygfx_rmat
        
        #we add 5 degrees as border
        if data["hfov"] >= data["vfov"]:
            self.obj_camera.fov = np.rad2deg(data["hfov"])+5
        else:
            self.obj_camera.fov = np.rad2deg(data["hfov"]*(data["vfov"]/data["hfov"]))+5

        prc = np.array([data["obj_x0"], data["obj_y0"], data["obj_z0"]])
        rmat = alzeka2rot([data["alpha"], data["zeta"], data["kappa"]])
        kmat = np.array([[-data["f"], 0, data["img_x0"]], 
                        [0, -data["f"], data["img_y0"]],
                        [0, 0, 1]])
        pmat = kmat@rmat.T@np.hstack((np.eye(3), -prc.reshape(3, 1)))
        data["pmat"] = pmat
        
        self.temporary_camera = data
        self.obj_canvas.request_draw()

    def reset_obj_canvas_camera(self):
        self.obj_camera.set_state(self.default_obj_camera_state)
        self.obj_canvas.request_draw()
            
    def save_obj_canvas_camera(self):
        self.obj_camera_state = None
        self.obj_camera_state = self.obj_camera.get_state()
    
    def load_obj_canvas_camera(self):
        if self.obj_camera_state is None:
            pass
        else:
            self.obj_camera.set_state(self.obj_camera_state)
            self.obj_canvas.request_draw()

    def coord_transform(self, point):
        geom = QgsGeometry.fromPointXY(point)
        sourceCRS = QgsCoordinateReferenceSystem(iface.mapCanvas().mapSettings().destinationCrs().authid())
        targetCRS = QgsCoordinateReferenceSystem(self.cam_lyr.crs())
        tr = QgsCoordinateTransform(sourceCRS, targetCRS, QgsProject.instance())
        geom.transform(tr)
        return geom.asPoint()
    
    def obj_canvas_camera_from_map(self):
        try:
            map_pos = self.coord_transform(iface.mapCanvas().center())
            map_extent = iface.mapCanvas().extent()

            map_width = map_extent.xMaximum() - map_extent.xMinimum()
            map_height = map_extent.yMaximum() - map_extent.yMinimum()
            
            map_z = map_width/np.tan(45/2)
            if map_z < self.min_xyz[2]:
                map_z = self.min_xyz[2]

            min_xy = np.array([self.min_xyz[0], self.min_xyz[1], 0])
            map_pos_loc = np.array([map_pos.x(), map_pos.y(), map_z]) - min_xy

            obj_camera_target = {'position':map_pos_loc,
                                        'rotation':np.array([0.,0.,0.,1.]), 
                                        'scale':np.array([1.,1.,1.]),
                                        'reference_up':np.array([0.,0.,1.]), 
                                        'fov':45.0, 
                                        'width':map_width, 
                                        'height':map_height, 
                                        'zoom':1.0, 
                                        'maintain_aspect':True,
                                        'depth_range':(1, 1000000)}
            
            self.obj_camera.set_state(obj_camera_target)
            self.obj_camera.show_pos((map_pos_loc[0], map_pos_loc[1], self.min_xyz[2]), up=(0,0,1))
            self.obj_canvas.request_draw()#self.animate)

        except:
            print('No project seems to be loaded!')

    def export_obj_canvas(self):
        try:
            def_res = [str(self.active_camera.img_w), str(self.active_camera.img_h)]
        except:
            def_res = ['1920','1080']

        def_name = self.parent.project_name

        export_dialog = ExportMetaDialog(def_res, def_name)
        export_dialog.exec_()
        depth_set = False

        if export_dialog.ok == True:
            export_path = QtWidgets.QFileDialog.getExistingDirectory(self)
        else:
            export_path=''

        if len(export_path) > 0:
            resolution = [int(export_dialog.res_width.text()), int(export_dialog.res_height.text())]
            
            offscreen_canvas = offscreenCanvas(size=(resolution[0], resolution[1]), pixel_ratio=1)
            offscreen_renderer = gfx.WgpuRenderer(offscreen_canvas)

            if export_dialog.depth_offset.text() == '':
                pass
            else:
                if int(export_dialog.depth_offset.text()) > 0:
                    depth_set = True  
                    curr_depth = self.obj_camera.depth_range
                    self.obj_camera.depth_range = (int(export_dialog.depth_offset.text()), curr_depth[1])
                else:
                    pass

            for pnts in self.obj_gcps_grp.children:
                pnts.visible = False

            bg = gfx.Background(None, gfx.BackgroundMaterial([0.086, 0.475, 0.671, 1]))
            self.obj_scene.remove(self.background)
            self.obj_scene.add(bg)

            offscreen_canvas.request_draw(offscreen_renderer.render(self.obj_scene, self.obj_camera))
            img = Image.fromarray(np.asarray(offscreen_canvas.draw()))
            img.save(os.path.join(export_path, export_dialog.file_name.text() + "_render.png"))

            self.obj_scene.remove(bg)
            self.obj_scene.add(self.background)

            for pnts in self.obj_gcps_grp.children:
                pnts.visible = True

            if depth_set:
                self.obj_camera.depth_range = (curr_depth[0], curr_depth[1])
        
        else:
            pass
        
    def show_image_menu(self, point):
        clicked_img = self.img_list.itemAt(point.x(), point.y())
        self.img_context_menu.exec(self.img_list.mapToGlobal(point))
        
    def camera_clicked(self, item):
        
        if item.isSelected():
            if item == self.prev_img_item:
                self.untoggle_camera(item)
                self.prev_img_item = None
            else:
                self.toggle_camera(item)
                self.prev_img_item = item

    def untoggle_camera(self, item):
        
        self.btn_ori_tool.setEnabled(False)
        self.btn_mono_tool.setEnabled(False)
        self.btn_mono_select.setEnabled(False)
        self.btn_mono_vertex.setEnabled(False)
        self.btn_obj_canvas_show_img.setEnabled(False)
        
        item.setCheckState(QtCore.Qt.Unchecked)
        self.img_list.clearSelection()
        
        self.obj_gcps_grp.clear()        
        self.img_plane_grp.clear()
        self.obj_canvas.request_draw()
        
        self.btn_obj_canvas_show_img.setChecked(False)
        self.btn_obj_canvas_show_img.setEnabled(False)
        
        expression = "iid = 'some_crap_that_doesnt_exist'"
        self.img_line_lyr.setSubsetString(expression)
        self.img_gcps_lyr.setSubsetString(expression)
        self.map_gcps_lyr.setSubsetString(expression)
        
        self.img_canvas.setLayers([])
        self.img_canvas.refresh()        
        
        self.active_camera = None
        self.setWindowTitle("%s" % (self.project_name))

        self.show_camera_in_obj_canvas(0)
        
    def toggle_camera(self, item):
        
        self.btn_ori_tool.setEnabled(True)
        
        # item = self.img_list.selectedItems()[0]
        item.setCheckState(QtCore.Qt.Checked)
        self.uncheck_list_items(item)
                    
        iid = item.text()
        iid_path = self.camera_collection[iid].path
        
        if not os.path.exists(iid_path):
            #iid_path = QFileDialog.getOpenFileName(None, "Image not found! Please, select new directory.", "", ("JPEG (*.jpeg)"))[0]
            while True:
                iid_dir = QFileDialog.getExistingDirectory(self, "Image not found! Please, select the directory to the image.")
                iid_path = iid_dir+'/'+iid+'.jpeg'
                if os.path.exists(iid_path) or iid_dir == '':
                    break
                else:
                    print('No image with the right name in this directory! (Only JPEG is supported)') 
                    continue

            self.camera_collection[iid].set_path(iid_path)
            field_idx = self.cam_lyr.fields().indexOf('path')
            
            for feat in self.cam_lyr.getFeatures():
                if feat['iid'] == iid:
                    feature_id = feat.id()
                    self.cam_lyr.startEditing()
                    self.cam_lyr.changeAttributeValue(feature_id,field_idx,iid_path)
                    self.cam_lyr.commitChanges()

        self.load_img(iid, iid_path)
        
        expression = "iid = '%s'" % (iid)
        self.img_line_lyr.setSubsetString(expression) #show only those lines which correspond to the currently selected image
        self.img_gcps_lyr.setSubsetString(expression)
        self.map_gcps_lyr.setSubsetString(expression)

        self.active_camera = self.camera_collection[iid]
        self.setWindowTitle("%s - %s" % (self.project_name, iid))
        
        #remove all children from the group --> removes all prevously loaded GCPs
        self.obj_gcps_grp.clear()
        
        for gcp in self.map_gcps_lyr.getFeatures():
            gcp_pos = [gcp["obj_x"]-self.min_xyz[0], 
                        gcp["obj_y"]-self.min_xyz[1], 
                        gcp["obj_z"]-self.min_xyz[2]]
            
            if gcp["active"] == '1':
                gcp_clr = (0.78, 0, 0, 1)
            else:
                gcp_clr = (0.86, 0.86, 0.86, 1)
            
            gcp_gfx = create_point_3d(gcp_pos, gcp["gid"], gcp_clr)
            self.obj_gcps_grp.add(gcp_gfx)

        if self.active_camera.is_oriented == 1:
            self.set_obj_canvas_camera(self.active_camera.asdict())
            
            self.btn_mono_tool.setEnabled(True)
            self.btn_mono_select.setEnabled(True)
            self.btn_mono_vertex.setEnabled(True)
            self.btn_obj_canvas_show_img.setEnabled(True)
                        
            self.mono_tool.set_camera(self.active_camera)
            self.mono_vertex_tool.set_camera(self.active_camera)
        else:
            self.btn_mono_tool.setEnabled(False)
            self.btn_mono_select.setEnabled(False)
            self.btn_mono_vertex.setEnabled(False)
            self.btn_obj_canvas_show_img.setEnabled(False)
            # self.btn_obj_canvas_show_img.setEnabled(False)

        self.show_camera_in_obj_canvas(iid)      
        self.obj_canvas.request_draw()
        
    def toggle_mono_tool(self):
        if self.btn_mono_tool.isChecked():                  #activate
            self.btn_ori_tool.setEnabled(False)
            self.btn_mono_select.setEnabled(False)
            self.btn_mono_vertex.setEnabled(False)
            #during monoplotting user cant adjust image orientation            
            self.img_canvas.setMapTool(self.mono_tool)
            self.img_list.setEnabled(False)
            self.mono_tool.reset()
        else:                                               #deactivate
            self.btn_ori_tool.setEnabled(True)
            self.btn_mono_select.setEnabled(True)
            self.btn_mono_vertex.setEnabled(True)
            self.img_list.setEnabled(True)
            self.img_canvas.unsetMapTool(self.mono_tool)
            self.img_canvas.setMapTool(self.img_pan_tool)
    
    def toggle_mono_select_tool(self):
        if self.btn_mono_select.isChecked():              #activate tool
                        
            self.btn_ori_tool.setEnabled(False)
            self.btn_mono_tool.setEnabled(False)
            self.btn_mono_vertex.setEnabled(False)
            self.img_list.setEnabled(False)
            
            #during monoplotting user cant adjust image orientation
            self.img_canvas.setMapTool(self.mono_select_tool)
            self.mono_select_tool.reset()
        else:
            self.btn_ori_tool.setEnabled(True)
            self.btn_mono_tool.setEnabled(True)#deactivate tool
            self.btn_mono_select.setEnabled(True)
            self.btn_mono_vertex.setEnabled(True)
            self.img_list.setEnabled(True)
            self.img_canvas.unsetMapTool(self.mono_select_tool)
            self.img_canvas.setMapTool(self.img_pan_tool)    
    
    def toggle_mono_vertex_tool(self):
        if self.btn_mono_vertex.isChecked():              #activate tool
            
            self.btn_ori_tool.setEnabled(False)
            self.btn_mono_tool.setEnabled(False)
            self.btn_mono_select.setEnabled(False)
            self.img_list.setEnabled(False)
            self.img_list.setEnabled(True)
            #during monoplotting user cant adjust image orientation
            self.img_canvas.setMapTool(self.mono_vertex_tool)
            self.mono_vertex_tool.reset()
        else:                                           #deactivate tool
            self.btn_ori_tool.setEnabled(True)
            self.btn_mono_tool.setEnabled(True)
            self.btn_mono_select.setEnabled(True)
            self.btn_mono_vertex.setEnabled(True)
            
            self.img_canvas.unsetMapTool(self.mono_vertex_tool)
            self.img_canvas.setMapTool(self.img_pan_tool)    
    
    def activate_gui_elements(self):
        self.img_list.setEnabled(True)
        self.img_menu.setEnabled(True)
        self.export_menu.setEnabled(True)
        self.view_menu.setEnabled(True)
        self.project_name = self.windowTitle()
                
    def activate_gcp_picking(self):

        #GCP picking in image space
        self.img_picker_tool = ImgPickerTool(self.img_canvas, GcpMetaDialog())
        self.img_picker_tool.set_camera(self.active_camera)
        self.img_picker_tool.set_layers(img_gcps_lyr=self.img_gcps_lyr, map_gcps_lyr=self.map_gcps_lyr)
        
        self.img_picker_tool.gcpAdded.connect(self.img_gcp_added)
        self.img_picker_tool.gcpEdit.connect(self.gcp_selected)
        self.img_picker_tool.gcpUpdated.connect(self.img_gcp_updated)
        self.img_picker_tool.gcpUpdated.connect(self.deselect_gcp)
        
        self.img_canvas.setMapTool(self.img_picker_tool)
        
        #GCP picking ib object space
        for mesh in self.terrain.children:
            mesh.add_event_handler(self.mesh_picking, "click")
    
    def gcp_selected(self, data):
        self.dlg_orient.gcp_selected(data, 1)

    def deactivate_gcp_picking(self):
        for mesh in self.terrain.children:
            mesh.remove_event_handler(self.mesh_picking, "click")
        self.img_canvas.setMapTool(self.img_pan_tool)
        
    def img_gcp_added(self, data):
        self.dlg_orient.add_gcp_to_table(data, gcp_type="img_space")
    
    def img_gcp_updated(self, data):
        self.dlg_orient.update_selected_gcp(data, gcp_type="img_space")
    
    def pick_to_world(self, event):
        face_ix = event.pick_info["face_index"]
            
        #face_coords are not normalized; hence, divide by their sum first before using the further
        face_coords = np.array(event.pick_info["face_coord"]).reshape(3, 1) 
        face_coords /= np.sum(face_coords)
        
        face_vertex_ix = event.pick_info["world_object"].geometry.indices.data[face_ix, :]
        face_vertex_pos = event.pick_info["world_object"].geometry.positions.data[face_vertex_ix, :]
        
        click_pos = np.sum(face_vertex_pos*face_coords, axis=0) 
        click_pos_global = click_pos + self.min_xyz
        return click_pos, click_pos_global
    
    def mesh_picking(self, event):
                
        if event.button == 1 and "Control" in event.modifiers:
                       
            click_pos_local, click_pos_global = self.pick_to_world(event)
            
            feat_geom = QgsPoint(click_pos_global[0], click_pos_global[1])

            if self.map_gcps_lyr.selectedFeatureCount() > 0:
                sel_fid = self.map_gcps_lyr.selectedFeatureIds()[0]
                self.map_gcps_lyr.startEditing()
                self.map_gcps_lyr.changeGeometry(sel_fid, QgsGeometry.fromPoint(feat_geom))
                self.map_gcps_lyr.changeAttributeValue(sel_fid, self.map_gcps_lyr_obj_x_ix, float(click_pos_global[0]))
                self.map_gcps_lyr.changeAttributeValue(sel_fid, self.map_gcps_lyr_obj_y_ix, float(click_pos_global[1]))
                self.map_gcps_lyr.changeAttributeValue(sel_fid, self.map_gcps_lyr_obj_z_ix, float(click_pos_global[2]))
                self.map_gcps_lyr.commitChanges()
                
                for pnts in self.obj_gcps_grp.children:
                    if int(self.sel_gid) == int(pnts.geometry.gid.data[0]):
                        pnts.geometry.positions.data[0, :] = click_pos_local                                      #update point geometry position
                        pnts.geometry.positions.update_range(0)
                        pnts.children[0].local.position = pnts.geometry.positions.data[0, :] + [0, 0, 10]   #update position of label
                        break
                    
                self.obj_canvas.request_draw()
                self.dlg_orient.update_selected_gcp({"obj_x":click_pos_global[0],
                                                     "obj_y":click_pos_global[1],
                                                     "obj_z":click_pos_global[2]}, gcp_type="obj_space")
                
                self.img_gcps_lyr.removeSelection()
                self.deselect_gcp()

            else:
                
                dlg_meta = GcpMetaDialog()
                
                img_gids = [feat.attributes()[self.img_gcps_gid_ix] for feat in self.img_gcps_lyr.getFeatures()]
                map_gids = [feat.attributes()[self.map_gcps_gid_ix] for feat in self.map_gcps_lyr.getFeatures()]
                pot_gids = list(set(img_gids).difference(map_gids))
                    
                dlg_meta.combo_gid.addItems(pot_gids)
                
                dlg_meta.line_iid.setText(self.active_camera.iid)
                
                dlg_meta.line_obj_x.setText("%.1f" % (click_pos_global[0]))
                dlg_meta.line_obj_y.setText("%.1f" % (click_pos_global[1]))
                dlg_meta.line_obj_z.setText("%.1f" % (click_pos_global[2]))
                
                dlg_meta.gids_not_allowed = map_gids
                
                result = dlg_meta.exec_() 

                if result:
                    
                    curr_gid = dlg_meta.combo_gid.currentText() 
                    
                    click_obj = create_point_3d(click_pos_local, curr_gid)
                    self.obj_gcps_grp.add(click_obj)
                    self.obj_canvas.request_draw()
                    
                    self.dlg_orient.add_gcp_to_table({"obj_x":click_pos_global[0], 
                                                      "obj_y":click_pos_global[1],
                                                      "obj_z":click_pos_global[2],
                                                      "gid":curr_gid},
                                                    gcp_type="obj_space")
                    
                    feat = QgsFeature(self.map_gcps_lyr.fields())
                    
                    feat.setGeometry(QgsPoint(click_pos_global[0], click_pos_global[1]))
                    feat.setAttribute("iid", self.active_camera.iid)
                    feat.setAttribute("gid", dlg_meta.combo_gid.currentText())
                    feat.setAttribute("obj_x", float(click_pos_global[0]))
                    feat.setAttribute("obj_y", float(click_pos_global[1]))
                    feat.setAttribute("obj_z", float(click_pos_global[2]))
                    feat.setAttribute("desc", dlg_meta.line_desc.text())
                    feat.setAttribute("active", 0)
                    (res, afeat) = self.map_gcps_lyr.dataProvider().addFeatures([feat])
                    self.map_gcps_lyr.commitChanges()
                    self.map_gcps_lyr.triggerRepaint()

        if event.button == 1 and "Alt" in event.modifiers:
            click_pos_local, _ = self.pick_to_world(event)
            mx = click_pos_local[0] + self.min_xyz[0]
            my = click_pos_local[1] + self.min_xyz[1]
            mz = click_pos_local[2] + self.min_xyz[2]

            gcp_dict = {}
            for feat in self.map_gcps_lyr.getFeatures():
                gcp_dict[feat['gid']] = (feat['obj_x'], feat['obj_y'], feat['obj_z'])

            dist = [np.sqrt((mx-gcp_dict[i][0])**2 + (my-gcp_dict[i][1])**2 + (mz-gcp_dict[i][2])**2) for i in gcp_dict.keys()]
            rix = dist.index(min(dist))

            if dist[rix] < 100:
                self.gcp_selected(rix)

    def zoom_to_point(self, event):
        
        #only conduct zoom to point if image is not currently shown in the object canvas
        if not self.btn_obj_canvas_show_img.isChecked():
        
            if event.button == 2 and "Control" in event.modifiers:
    
                click_pos_local, _ = self.pick_to_world(event)
                
                self.obj_camera_origin = self.obj_camera.get_state()
                self.origin_memory.append(self.obj_camera_origin)

                vektor = [click_pos_local[0] - self.obj_camera_origin['position'][0], click_pos_local[1] - self.obj_camera_origin['position'][1], click_pos_local[2] - self.obj_camera_origin['position'][2]]
                position = [self.obj_camera_origin['position'][0] + vektor[0]/1.05, self.obj_camera_origin['position'][1] + vektor[1]/1.05, self.obj_camera_origin['position'][2] + vektor[2]/1.05]

                self.obj_camera_target = {'position':np.array([position[0], position[1], position[2]]),
                                            'rotation':self.obj_camera_origin['rotation'], 
                                            'scale':self.obj_camera_origin['scale'],
                                            'reference_up':self.obj_camera_origin['reference_up'], 
                                            'fov':self.obj_camera_origin['fov'], 
                                            'width':self.obj_camera_origin['width'], 
                                            'height':self.obj_camera_origin['height'], 
                                            'zoom':self.obj_camera_origin['zoom'], 
                                            'maintain_aspect':self.obj_camera_origin['maintain_aspect'],
                                            'depth_range':self.obj_camera_origin['depth_range']}
                self.obj_camera.set_state(self.obj_camera_target)

                self.obj_camera.show_pos((click_pos_local[0], click_pos_local[1], click_pos_local[2]), up=(0,0,1))
                
                self.obj_canvas.request_draw()
                
            if event.button == 2 and "Alt" in event.modifiers:
                if len(self.origin_memory) > 0:
                    self.obj_camera.set_state(self.origin_memory[-1])
                    self.origin_memory.pop(-1)
                    self.obj_canvas.request_draw()
                else:
                    pass

    def toggle_project_mouse_pos(self):
        self.project_pos_toggled = True
        
        #rubber band for storing reprojected poin from 3d canvas into image
        self.img_rubber = QgsRubberBand(self.img_canvas, Qgis.GeometryType.Point)
        self.img_rubber.setIcon(1)
        self.img_rubber.setColor(QColor(252,15,192, 255))
        self.img_rubber.setIconSize(15)
        
        for mesh in self.terrain.children:
            mesh.add_event_handler(self.reproject_pos, "pointer_move")
    
    def untoggle_project_mouse_pos(self):       
        if self.project_pos_toggled:
            for mesh in self.terrain.children:
                mesh.remove_event_handler(self.reproject_pos, "pointer_move")
            self.project_pos_toggled = False
            self.img_rubber.reset()
            
    def reproject_pos(self, event):
        _, click_pos_global = self.pick_to_world(event)
        
        click_pos_img_hom = self.temporary_camera["pmat"]@np.append(click_pos_global.ravel(), values=1)
        click_pos_img = click_pos_img_hom[:2] / click_pos_img_hom[-1]
        
        #display only if the reprojected point is within the image
        if ((click_pos_img[0] > 0) and (click_pos_img[0] <= self.active_camera.img_w)):
            if (click_pos_img[1] < 0) and (click_pos_img[1] >= self.active_camera.img_h*(-1)):
                self.img_rubber.removeLastPoint()
                self.img_rubber.addPoint(QgsPointXY(click_pos_img[0], click_pos_img[1]))
                self.img_rubber.show()

    def show_offset_in_obj_canvas(self, offset):
        if self.dlg_orient.first_time == True:
            self.obj_cam_state = self.obj_camera.get_state()

        position = [self.obj_cam_state['position'][0] + offset['offset_x'], 
                    self.obj_cam_state['position'][1] + offset['offset_y'], 
                    self.obj_cam_state['position'][2] + offset['offset_z']]

        obj_camera_target = {'position':np.array([position[0], position[1], position[2]]),
                                    'rotation':self.obj_cam_state['rotation'], 
                                    'scale':self.obj_cam_state['scale'],
                                    'reference_up':self.obj_cam_state['reference_up'], 
                                    'fov':self.obj_cam_state['fov'], 
                                    'width':self.obj_cam_state['width'], 
                                    'height':self.obj_cam_state['height'], 
                                    'zoom':self.obj_cam_state['zoom'], 
                                    'maintain_aspect':self.obj_cam_state['maintain_aspect'],
                                    'depth_range':self.obj_cam_state['depth_range']}
        
        self.obj_camera.set_state(obj_camera_target)
        self.obj_canvas.request_draw()

